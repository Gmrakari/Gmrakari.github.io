---
title: C++类成员函数中重载/重写(覆盖)/重定义(隐藏)的区别
date: 2021-04-23 10:18:39
tags: [Interview,C++]

---

#### C++类成员函数中重载/重写(覆盖)/重定义(隐藏)的区别
函数重写(覆盖)(Function Override),函数覆盖就是函数重写  
定义:  
- 派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写  
- 关于返回值类型存在一种特殊情况，即协变返回类型(Covariant return type)  
**虚函数重写与协变返回类型**
如果虚函数函数返回指针或者引用时,子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型

```C++
#include <iostream>
using namespace std;

class A{};

class B:public A{};

class Base
{
public:
	virtual A& show(){
		cout<<"In Base"<<endl;
		return *(new A);
	}
};

class Dericed : public Base{
public:
	//返回值协变，构成虚函数重写
	B& show(){
		cout<<"In Dericed"<<endl;
		return *(new B);
	}
};

```
**注意事项：**
- 函数覆盖就是虚函数重写，而不是函数被"覆盖"。
- 从上面的代码可以分析出，函数是不可能被“覆盖”的。有些人可能会错误地认为函数覆盖会导致函数被“覆盖”而“消失”，将不能被访问，事实上只要通过作用域运算符::就可以访问到被覆盖的函数。因此，不存在被“覆盖”的函数	
- 函数覆盖是函数隐藏的特殊情况
- 对比函数覆盖和函数隐藏的定义，不难发现函数覆盖其实是函数隐藏的特例
- 如果派生类中定义了一个与基类虚函数同名但参数列表不同的非virtual函数，则此函数是一个普通成员函数(非虚函数),并形成对基类中同名虚函数的隐藏，而非虚函数覆盖(重写)
- 《C++高级进阶教程》中认为函数的隐藏与覆盖是两个不同的概念。**隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象，而覆盖是为了实现动态联编，是一个动态概念。**  
但隐藏和覆盖也有联系：  
- 形成覆盖的两个函数之间一定形成隐藏。例如，可以对虚函数采用"实调用"，即尽管被调用的是虚函数，但是被调用函数的地址还是在编译阶段静态确定的，那么派生类中的虚函数仍然形成对基类中虚函数的同名隐藏  
```C++
#include <iostream>
using namespace std;

class Base{
public:
	virtual void show(){
		cout<<"In Base"<<endl;
	}
};

class Derived:public Base{
	public:
		void show(){
			cout<<"In Derived"<<endl;
		}
}

int main(){
	Base b;
	b.show();

	Derived d;
	d.show();			//对函数show()的实调用
	d.Base::show();		//对函数show()的实调用
	Base *pb = NULL;
	
	pb = &d;
	pb->show();			//对函数show()的虚调用
	pb->Base::show();	//对函数show()的实调用
}

//运行结果
/*
Value:

In Base
In Derived
In Base
In Derived
In Base

 */

```

**注意事项： **
- 对比函数隐藏与函数重载的定义可知
- 派生类成员函数与基类成岩函数同名但参数不同。此时基类成员函数将被隐藏(注意别与重载混淆，重载发生在同一个类中)
- 函数重载发生在同一作用域，函数隐藏发生在不同的作用域

区分函数重载、函数隐藏、函数覆盖和函数重写  

- 1、函数重载发生在相同作用域  
- 2、函数隐藏发生在不同作用域  
- 3、函数覆盖就是函数重写。准确地叫做虚函数覆盖和虚函数重写，也实函数隐藏的特例  

参考:[https://www.cnblogs.com/DannyShi/p/4593735.html#4634830]